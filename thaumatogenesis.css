@keyframes rotateY {
  0% {
    transform: rotate3d(0, 1, 0, 0deg);
  }
  25% {
    transform: rotate3d(0, 1, 0, 90deg);
  }
  50% {
    transform: rotate3d(0, 1, 0, 180deg);
  }
  75% {
    transform: rotate3d(0, 1, 0, 270deg);
  }
  100% {
    transform: rotate3d(0, 1, 0, 360deg);
  }
}
@keyframes inverseRotateY {
  0% {
    transform: rotate3d(0, 1, 0, 0deg);
  }
  25% {
    transform: rotate3d(0, 1, 0, -90deg);
  }
  50% {
    transform: rotate3d(0, 1, 0, -180deg);
  }
  75% {
    transform: rotate3d(0, 1, 0, -270deg);
  }
  100% {
    transform: rotate3d(0, 1, 0, -360deg);
  }
}
.spinimage {
  animation: 3s linear 1s infinite running both rotateY;
}
body {
  padding: 0;
  margin: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
.game-container {
  width: 100%;
  height: 100%;
}
.main-renderer-container {
  width: 100%;
  height: 100%;
}
.main-renderer {
  width: 100%;
  height: 100%;
}
.css-renderer {
  width: 100%;
  height: 100%;
  background-color: orange;
}
.test.square {
  width: 100px;
  height: 100px;
  position: absolute;
  background-color: black;
  border: 2px solid red;
  outline: 1px solid transparent;
}
/* [markdown]
I have included this as a demonstration of the very unintuitive way in which transforms work. It's also my test cube.
Transforms are very unintuitive, so **listen up.**
Here's the rundown:
  - CSS 3d transforms appy at the **center of the object** they affect.
  - Since in JavaScript we are calculating our coordinates based on transformation matrices, we need all of our texture squares to start at a consistent point.
  - The easy way to do this is as follows:
    1) We set our texture container (in this case .face) to be 0px by 0px.
    2) We set our texture squares (in this case .face::after) to be the desired size (in this case 100px by 100px).
      ! In the specific case of ::after objects, we need to set **min-width** and not just width since for some reason CSS hates me. idk man
    3) Since this is testing, we set the background of our texture squares to the desired color.
    4) We apply our transform to the texture container that's 0x0. Since it is centered at the origin, this means the transform will __always apply around the origin__.
      ! WE DO NOT APPLY OUR TRANSFORM TO THE TEXTURE SQUARE. EVER. THIS LEADS TO EXTRAORDINARILY INCONSISTENT RESULTS.
    5) Finally, we set our texture square to position: absolute and top, left: 0 so that all of our texture squares start at the top left and go down and to the right. This corresponds to how we do our UV coords in JavaScript.
Also, who decided transforms would apply __from the right to the left?!!__ >::(
*/
.face {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  position: absolute;
  backface-visibility: inherit;
  font-size: 60px;
  color: white;
}
.face .after {
  position: absolute;
  top: 0px;
  right: 0px;
  min-width: 100px;
  height: 100px;
  text-align: center;
  line-height: 100px;
  background-color: inherit;
}
.front {
  background: rgba(90, 90, 90, 0.7);
  transform: translateZ(50px) translateX(50px);
}
.front .after {
  content: "1";
}
.back {
  background: rgba(0, 210, 0, 0.7);
  transform: rotateY(180deg) translateZ(50px) translateX(50px);
}
.back::after {
  content: "2";
}
.right {
  background: rgba(210, 0, 0, 0.7);
  transform: rotateY(90deg) translateZ(50px) translateX(50px);
}
.right::after {
  content: "3";
}
.left {
  background: rgba(0, 0, 210, 0.7);
  transform: rotateY(-90deg) translateZ(50px) translateX(50px);
}
.left::after {
  content: "4";
}
.top {
  background: rgba(210, 210, 0, 0.7);
  transform: rotateX(90deg) translateY(-50px) translateX(50px);
}
.top::after {
  content: "5";
}
.bottom {
  background: rgba(210, 0, 210, 0.7);
  transform: translateY(100px) rotateX(-90deg) translateY(-50px) translateX(50px);
}
.bottom::after {
  content: "6";
}
#renderercss {
  width: 100%;
  height: 100%;
}
.render-3d {
  transform-style: preserve-3d;
  margin: auto;
}
.perspectivefar {
  perspective: 100vh;
  perspective-origin: 50% 50%;
  width: 100%;
  height: 100vh;
}
.hidden {
  visibility: hidden;
}
.center {
  margin: auto;
}
.ground {
  transform: translate3d(-2010px, 250px, -2010px) rotateX(90deg);
  transform-style: preserve-3d;
}
.ground .after {
  display: inline-block;
  position: absolute;
  width: 4000px;
  height: 4000px;
  background-image: radial-gradient(circle farthest-corner at center, red 1%, transparent 1.1%, transparent 100%), repeating-linear-gradient(to bottom, #ccc 0, #ccc calc(5 * 1px), transparent calc(5 * 1px), transparent 200px), repeating-linear-gradient(to right, #ccc 0, #ccc calc(5 * 1px), transparent calc(5 * 1px), transparent 200px);
  background-size: 100px 100px;
  /* Size of the grid cells */
  content: " ";
  border: 10px solid red;
  outline: 1px solid  transparent;
}
.camera {
  transform-style: preserve-3d;
}
.camera.translate-in {
  transform: translate3d(0px, calc(50vh), 100vh);
}
.identify {
  z-index: 100;
  position: relative;
  width: 200%;
  height: 200%;
  right: calc((200% - 100%) / 2 + 1px);
  bottom: calc((200% - 100%) / 2 + 1px);
}
.identifierbox {
  position: absolute;
  aspect-ratio: 1;
  border: 2px solid black;
}
.ident-boxes {
  background-color: #000;
  color: #FFF;
  border: 2px solid #555;
  font-family: 'Consolas', 'Courier New', Courier, monospace;
  padding: 2px;
}
.properties {
  min-width: 200px;
  min-height: 100px;
  position: absolute;
  right: -100%;
  background-color: #000;
  color: #FFF;
  border: 2px solid #555;
  font-family: 'Consolas', 'Courier New', Courier, monospace;
  padding: 2px;
}
.properties .property {
  font-size: 0.75em;
}
.properties .property .name::after {
  content: ": ";
}
.properties .property .value:has(.alternates) {
  text-decoration: 1px dotted white underline;
}
.properties .property .value:has(.alternates) .alternates {
  display: none;
}
.properties .property .value:has(.alternates):hover .alternates {
  display: block;
  position: absolute;
}
.properties-html {
  display: none;
}
.object {
  position: absolute;
  top: 0px;
  left: 0px;
  height: 0px;
  width: 0px;
}
.transform-origin {
  position: absolute;
  top: 0px;
  left: 0px;
  height: 0px;
  width: 0px;
}
#transformtest {
  background-image: radial-gradient(circle farthest-corner at 50px 50px, white 4px, transparent 4px);
}
#mark1 {
  min-height: 400px;
  min-width: 400px;
  background-color: white;
  right: 0;
  top: 0;
  position: absolute;
  background-image: attr(data-gradients);
}
